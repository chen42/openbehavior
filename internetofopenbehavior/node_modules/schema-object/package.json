{
  "_args": [
    [
      {
        "raw": "schema-object",
        "scope": null,
        "escapedName": "schema-object",
        "name": "schema-object",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "/home/ethan/programming/ethanwillis/openbehavior/internetofopenbehavior"
    ]
  ],
  "_from": "schema-object@latest",
  "_id": "schema-object@4.0.11",
  "_inCache": true,
  "_location": "/schema-object",
  "_nodeVersion": "6.9.2",
  "_npmOperationalInternal": {
    "host": "packages-18-east.internal.npmjs.com",
    "tmp": "tmp/schema-object-4.0.11.tgz_1488764803481_0.8098159902729094"
  },
  "_npmUser": {
    "name": "scotthovestadt",
    "email": "scott.hovestadt@gmail.com"
  },
  "_npmVersion": "3.10.9",
  "_phantomChildren": {},
  "_requested": {
    "raw": "schema-object",
    "scope": null,
    "escapedName": "schema-object",
    "name": "schema-object",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/schema-object/-/schema-object-4.0.11.tgz",
  "_shasum": "8264684ca889bc60386928df05121819b3e54df2",
  "_shrinkwrap": null,
  "_spec": "schema-object",
  "_where": "/home/ethan/programming/ethanwillis/openbehavior/internetofopenbehavior",
  "author": {
    "name": "Scott Hovestadt"
  },
  "bugs": {
    "url": "https://github.com/scotthovestadt/schema-object/issues"
  },
  "dependencies": {
    "babel-polyfill": "^6.16.0",
    "harmony-reflect": "^1.5.0",
    "in-publish": "^2.0.0",
    "lodash": "^4.17.2"
  },
  "description": "Enforce schema on JavaScript objects, including type, transformation, and validation. Supports extends, sub-schemas, and arrays.",
  "devDependencies": {
    "babel-core": "6.21.0",
    "babel-plugin-transform-builtin-extend": "1.1.0",
    "babel-plugin-transform-class-properties": "6.19.0",
    "babel-preset-es2015": "6.18.0",
    "gulp": "3.9.1",
    "gulp-babel": "6.1.2",
    "gulp-mocha": "3.0.1",
    "gulp-mocha-phantomjs": "0.12.0",
    "load-plugins": "2.1.2",
    "minimist": "1.2.0",
    "should": "11.x.x"
  },
  "directories": {
    "test": "test"
  },
  "dist": {
    "shasum": "8264684ca889bc60386928df05121819b3e54df2",
    "tarball": "https://registry.npmjs.org/schema-object/-/schema-object-4.0.11.tgz"
  },
  "engines": {
    "node": ">=0.11"
  },
  "files": [
    "dist",
    "typescript"
  ],
  "gitHead": "a0467ecf514ee46eb646f172350f21f3304bbf4d",
  "homepage": "https://github.com/scotthovestadt/schema-object#readme",
  "keywords": [
    "javascript",
    "schema",
    "extends",
    "type",
    "transformation",
    "validation",
    "object",
    "array"
  ],
  "license": "BSD",
  "main": "dist/schemaobject.js",
  "maintainers": [
    {
      "name": "scotthovestadt",
      "email": "scott.hovestadt@gmail.com"
    }
  ],
  "name": "schema-object",
  "optionalDependencies": {},
  "readme": "Schema Object [![Build Status](https://travis-ci.org/scotthovestadt/schema-object.png?branch=master)](https://travis-ci.org/scotthovestadt/schema-object)\n==================\n\nDesigned to enforce schema on Javascript objects. Allows you to specify type, transformation and validation of values via a set of attributes. Support for sub-schemas included.\n\n```\nnpm install schema-object\n```\n```\nbower install schema-object\n```\n\n**TypeScript typings included. Node and browser environments supported.**\n\nFor older versions of Node, run node with the harmony proxies ````--harmony_proxies```` flag. This flag is on by default in newer NodeJS versions.\n\n\n# Very basic usage example\n```js\nvar SchemaObject = require('schema-object');\n\n// Create User schema\nvar User = new SchemaObject({\n  firstName: String,\n  lastName: String,\n  birthDate: Date\n});\n\n// Initialize instance of user\nvar user = new User({firstName: 'Scott', lastName: 'Hovestadt', birthDate: 'June 21, 1988'});\nconsole.log(user);\n\n// Prints:\n{ firstName: 'Scott',\n  lastName: 'Hovestadt',\n  birthDate: Tue Jun 21 1988 00:00:00 GMT-0700 (PDT) }\n```\n\n# Advanced example\n```js\nvar SchemaObject = require('schema-object');\n\n// Create custom basic type\n// Type can be extended with more properties when defined\nvar NotEmptyString = {type: String, minLength: 1};\n\n// Create sub-schema for user's Company\nvar Company = new SchemaObject({\n  // Any string will be magically parsed into date\n  startDate: Date,\n  endDate: Date,\n\n  // String with properties\n  name: NotEmptyString,\n\n  // Typed array\n  tags: [NotEmptyString]\n});\n\n// Create User schema\nvar User = new SchemaObject({\n  // Basic user information using properties\n  firstName: NotEmptyString,\n  lastName: NotEmptyString,\n\n  // Extend \"NotEmptyString\" with enum property\n  gender: {type: NotEmptyString, enum: ['m', 'f']},\n\n  // Sub-object with enforced type\n  work: Company\n}, {\n  // Add methods to User prototype\n  methods: {\n    getDisplayName: function() {\n      return this.firstName + ' ' + this.lastName;\n    }\n  }\n});\n\n// Create Account schema by extending User schema\nvar Account = User.extend({\n  // Add username to schema\n  username: NotEmptyString,\n\n  // Special behavior will transform password to hash if necessary\n  // https://www.npmjs.com/package/password-hash\n  password: {type: String, stringTransform: function(string) {\n    if(!passwordHash.isHashed(string)) {\n      string = passwordHash.generate(string);\n    }\n    return string;\n  }}\n}, {\n  methods: {\n    getDisplayName: function() {\n      // If available, use username as display name\n      // Otherwise fall back to first name and last name\n      return this.username || this.super();\n    }\n  }\n});\n\n// Initialize a new instance of the User with a value\nvar account = new Account({\n  username: 'scotthovestadt',\n  password: 'hunter2',\n  firstName: 'Scott',\n  lastName: 'Hovestadt',\n  gender: 'm',\n  work: {\n    name: 'My Company',\n    startDate: 'June 1, 2010'\n  }\n});\n\nconsole.log(account.getDisplayName());\n\n// Prints:\n\"scotthovestadt\"\n\nconsole.log(account);\n\n// Prints:\n{ firstName: 'Scott',\n  lastName: 'Hovestadt',\n  gender: 'm',\n  work:\n   { startDate: Tue Jun 01 2010 00:00:00 GMT-0700 (PDT),\n     name: 'My Company' },\n  username: 'scotthovestadt' }\n```\n\n# Static Methods\n\n## extend\n\nAllows you to extend SchemaObject instance schema and options.\n\n```js\nvar Person = new SchemaObject({\n  firstName: String,\n  lastName: String\n}, {\n  constructors: {\n    fromFullName: function(fullName) {\n      fullName = fullName.split(' ');\n      this.firstName = fullName[0];\n      this.lastName = fullName[1];\n    }\n  },\n  methods: {\n    getDisplayName: function() {\n      return this.firstName + ' ' + this.lastName;\n    }\n  }\n});\n\nvar Employee = Person.extend({\n  id: Number\n}, {\n  methods: {\n    getDisplayName: function() {\n      return '[Employee ID ' + this.id + '] ' + this.super();\n    }\n  }\n});\n\nvar john = Employee.fromFullName('John Smith');\njohn.id = 1;\n\nconsole.log(john.getDisplayName());\n\n// Prints:\n\"[Employee ID 1] John Smith\"\n```\n\n\n# Methods\n\n## clone\n\nClones SchemaObject and all sub-objects and sub-arrays into another SchemaObject container. Writes on any sub-objects or sub-arrays will not touch the original.\n```js\nvar User = new SchemaObject({\n  firstName: String,\n  lastName: String\n});\n\nvar user = new User({firstName: 'Scott', lastName: 'Hovestadt'});\n\nvar anotherUser = user.clone();\nanotherUser.firstName = 'John';\nanotherUser.lastName = 'Smith';\n\nconsole.log(user);\nconsole.log(anotherUser);\n\n\n// Prints:\n{ firstName: 'Scott',\n  lastName: 'Hovestadt' }\n{ firstName: 'John',\n  lastName: 'Smith' }\n```\n\n## toObject\n\ntoObject returns a cloned primitive object, stripped of all magic. Writes on any sub-objects or sub-arrays will not touch the original. All values will be typecasted and transformed, but future writes to the primitive object will not. The [invisible attribute](https://github.com/scotthovestadt/schema-object#invisible) can be used to ensure an index stored on the SchemaObject will not be written to the primitive object. toObject is automatically called if a SchemaObject is passed to JSON.stringify.\n```js\nvar User = new SchemaObject({\n  firstName: String,\n  lastName: String,\n  birthDate: Date\n});\n\nvar user = new User({firstName: 'Scott', lastName: 'Hovestadt', birthDate: 'June 21, 1988'});\nconsole.log(user);\n\n// Prints:\n{ firstName: 'Scott',\n  lastName: 'Hovestadt',\n  birthDate: Tue Jun 21 1988 00:00:00 GMT-0700 (PDT) }\n```\n\n## populate\n\npopulate will copy an object's values.\n```js\nvar User = new SchemaObject({\n  firstName: String,\n  lastName: String\n});\n\nvar user = new User();\nuser.populate({firstName: 'Scott', lastName: 'Hovestadt'});\nconsole.log(user);\n\n// Prints:\n{ firstName: 'Scott',\n  lastName: 'Hovestadt' }\n```\n\n## clear\n\nclear removes all values.\n```js\nvar User = new SchemaObject({\n  firstName: String,\n  lastName: String\n});\n\nvar user = new User({firstName: 'Scott', lastName: 'Hovestadt'});\nconsole.log(user);\n\n// Prints:\n{ firstName: 'Scott',\n  lastName: 'Hovestadt' }\n\nuser.clear();\nconsole.log(user);\n\n// Prints:\n{ firstName: undefined,\n  lastName: undefined }\n```\n\n## isErrors / getErrors / clearErrors\n\nSee documentation on [Errors](https://github.com/scotthovestadt/schema-object#errors).\n\n\n# Options\n\nWhen you create the SchemaObject, you may pass a set of options as a second argument. These options allow you to fine-tune the behavior of your objects for specific needs.\n\n## constructors\n\nThe constructors option allows you to override the default or attach new constructors to your SchemaObject-created class.\n\n```js\nvar Person = new SchemaObject({\n  firstName: String,\n  lastName: String\n}, {\n  constructors: {\n    // Override default constructor\n    default: function(values) {\n      // Will call this.populate\n      this.super(values);\n\n      // Populate default values with custom constructor\n      if(this.firstName === undefined) {\n        this.firstName = 'John';\n      }\n      if(this.lastName === undefined) {\n        this.lastName = 'Smith';\n      }\n    },\n\n    // Create new constructor used by calling Person.fromFullName\n    fromFullName: function(fullName) {\n      // Will call default constructor\n      this.super();\n\n      fullName = fullName.split(' ');\n      if(fullName[0]) {\n        this.firstName = fullName[0];\n      }\n      if(fullName[1]) {\n        this.lastName = fullName[1];\n      }\n    }\n  }\n});\n\nvar person = new Person({ firstName: 'Scott' });\n// OR\nvar person = Person.fromFullName('Scott');\n\nconsole.log(person);\n\n// Prints:\n{ firstName: 'Scott',\n  lastName: 'Smith' }\n```\n\n## methods\n\nThe methods option allows you to attach new methods to your SchemaObject-created class.\n\n```js\nvar Person = new SchemaObject({\n  firstName: String,\n  lastName: String\n}, {\n  methods: {\n    getFullName: function() {\n      return this.firstName + ' ' + this.lastName;\n    }\n  }\n});\n\nvar person = new Person({ firstName: 'Scott', lastName: 'Hovestadt' });\nconsole.log(person.getFullName());\n\n// Prints:\n{ 'Scott Hovestadt' }\n```\n\n## toObject(object)\n\ntoObject allows you to transform the model before the result of toObject() is passed back.\n\nThis example shows how it could be used to ensure transform all strings to uppercase.\n```js\nvar Model = new SchemaObject({\n  string: String\n}, {\n  toObject: function(object) {\n    _.each(object, function(value, key) {\n      if(_.isString(value)) {\n        object[key] = value.toUpperCase();\n      }\n    });\n    return object;\n  }\n});\n\nvar model = new Model();\nmodel.string = 'a string';\nconsole.log(model.string);\n\n// Prints:\n{ 'a string' }\n\nvar simpleObject = model.toObject();\nconsole.log(simpleObject.string);\n\n// Prints:\n{ 'A STRING' }\n```\n\n## inheritRootThis\n\ninheritRootThis (default: false) should be set to true if you want your nested SchemaObjects to have the \"this\" context of the root SchemaObject. SchemaObjects created with the shorthand syntax are considered a part of the parent object and have this enabled automatically.\n\n\n## setUndefined\n\nsetUndefined (default: false) allows you to specify if an unset value is written when toObject() is called. By default, the behavior is not to write unset values. This means if there is a null/undefined primitive, an empty array, or an empty object it will not be written to the object when toObject() is called.\n\nThis value should set to true if:\n- You want your database (Mongo, etc) to write unset indexes and overwrite existing fields with empty values.\n- You want to write undefined values when exporting to JSON explicitly.\n- You want toObject() to contain empty arrays and objects.\n\n## preserveNull\n\npreserveNull (default: false) allows you to set `null` to any field. The default behavior will treat null as unsetting the field.\n\nThis value should set to true if you're intentionally using null and know the difference between null and undefined.\n\n## strict\n\nstrict (default: true) allows you to specify what happens when an index is set on your SchemaObject that does not exist in the schema. If strict mode is on, the index will be ignored. If strict mode is off, the index will automatically be created in the schema when it's set with type \"any\".\n\nWith strict mode on (default):\n```js\nvar Profile = new SchemaObject({\n  id: String\n}, {\n  strict: true\n});\n\nvar profile = new Profile();\nprofile.id = 'abc123';\nprofile.customField = 'hello';\n\n// Prints:\n{ id: 'abc123' }\n```\n\nWith strict mode off:\n```js\nvar Profile = new SchemaObject({\n  id: String\n}, {\n  strict: false\n});\n\nvar profile = new Profile();\nprofile.id = 'abc123';\nprofile.customField = 'hello';\n\n// Prints:\n{ id: 'abc123', customField: 'hello' }\n```\n\n## dotNotation\n\ndotNotation (default: false) allows you to access deep fields in child objects using dot notation. If dot notation is on, getting or setting \"profile.name\" will look inside the object for a child object \"profile\" and then for key \"name\", instead of simply setting the index \"profile.name\" on the parent object.\n\nThe following example turns off strict mode to demonstrate the differences when toggling dot notation on or off, although dot notation can be used with or without strict mode.\n\nWith dot notation off (default):\n```js\nvar User = new SchemaObject({\n}, {\n  dotNotation: false,\n  strict: false\n});\n\nvar user = new User();\nuser['profile.name'] = 'Scott';\n\n// Prints:\n{ 'profile.name': 'Scott' }\n```\n\nWith dot notation on:\n```js\nvar User = new SchemaObject({\n}, {\n  dotNotation: true,\n  strict: false\n});\n\nvar user = new User();\nuser['profile.name'] = 'Scott';\n\n// Prints:\n{ profile: { name: 'Scott' } }\n```\n\n## keysIgnoreCase\n\nkeysIgnoreCase (default: false) allows you to set indexes without worrying about the casing of the key.\n\nWith keys ignore case off (default):\n```js\nvar User = new SchemaObject({\n  firstName: String\n}, {\n  keyIgnoreCase: false\n});\n\nvar user = new User();\nuser.firstname = 'Scott';\n\n// Prints:\n{}\n```\n\nWith keys ignore case on:\n```js\nvar User = new SchemaObject({\n  firstName: String\n}, {\n  keyIgnoreCase: true\n});\n\nvar user = new User();\nuser.firstname = 'Scott';\n\n// Prints:\n{ firstName: 'Scott' }\n```\n\n\n## onBeforeValueSet(value, key) / onValueSet(value, key)\n\nonBeforeValueSet / onValueSet allow you to bind an event handler to all write operations on an object. Currently, it will only notify of write operations on the object itself and will not notify you when child objects are written to. If you return false or throw an error within the onBeforeValueSet handler, the write operation will be cancelled. Throwing an error will add the error to the error stack.\n```js\nvar User = new SchemaObject({\n  name: String\n}, {\n  onBeforeValueSet: function(value, key) {\n    if(key === 'name' && value === 'Scott') {\n      return false;\n    }\n  }\n});\n\nvar user = new User();\n\nuser.name = 'Scott';\n// Prints:\n{ name: undefined }\n\nuser.name = 'Scott Hovestadt';\n// Prints:\n{ name: 'Scott Hovestadt' }\n```\n\n\n# Errors\n\nWhen setting a value fails, an error is generated silently. Errors can be retrieved with getErrors() and cleared with clearErrors().\n\n```js\nvar Profile = new SchemaObject({\n  id: {type: String, minLength: 5}\n});\n\nvar profile = new Profile();\nprofile.id = '1234';\n\nconsole.log(profile.isErrors());\n\n// Prints:\ntrue\n\nconsole.log(profile.getErrors());\n\n// Prints:\n[ { errorMessage: 'String length too short to meet minLength requirement.',\n    setValue: '1234',\n    originalValue: undefined,\n    fieldSchema: { name: 'id', type: 'string', minLength: 5 } } ]\n\n// Clear all errors.\nprofile.clearErrors();\n```\n\n\n# Types\n\nSupported types:\n- String\n- Number\n- Boolean\n- Date\n- Array (including types within Array)\n- Object (including typed SchemaObjects for sub-schemas)\n- 'alias'\n- 'any'\n\nWhen a type is specified, it will be enforced. Typecasting is enforced on all types except 'any'. If a value cannot be typecasted to the correct type, the original value will remain untouched.\n\nTypes can be extended with a variety of attributes. Some attributes are type-specific and some apply to all types.\n\nCustom types can be created by defining an object with type properties.\n```js\nvar NotEmptyString = {type: String, minLength: 1};\ncountry: {type: NotEmptyString, default: 'USA'}\n```\n\n## General attributes\n\n### transform\nCalled immediately when value is set and before any typecast is done.\n```js\nname: {type: String, transform: function(value) {\n  // Modify the value here...\n  return value;\n}}\n```\n\n### default\nProvide default value. You may pass value directly or pass a function which will be executed when the object is initialized. The function is executed in the context of the object and can use \"this\" to access other properties (which .\n```js\ncountry: {type: String, default: 'USA'}\n```\n\n### getter\nProvide function to transform value when retrieved. Executed in the context of the object and can use \"this\" to access properties.\n```js\nstring: {type: String, getter: function(value) { return value.toUpperCase(); }}\n```\n\n### required\nIf true, a value must be provided. If a value is not provided, an error will be generated silently. If used in conjunction with default, this check will always pass.\n```js\nfullName: {type: String, required: true}\n```\n\n### readOnly\nIf true, the value can be read but cannot be written to. This can be useful for creating fields that reflect other values.\n```js\nfullName: {type: String, readOnly: true, default: function(value) {\n  return (this.firstName + ' ' + this.lastName).trim();\n}}\n```\n\n### invisible\nIf true, the value can be written to but isn't outputted as an index when toObject() is called. This can be useful for creating aliases that redirect to other indexes but aren't actually present on the object.\n```js\nzip: String,\npostalCode: {type: 'alias', invisible: true, index: 'zip'}\n// this.postalCode = 12345 -> this.toObject() -> {zip: '12345'}\n```\n\n\n## String\n\n### stringTransform\nCalled after value is typecast to string **if** value was successfully typecast but called before all validation.\n```js\npostalCode: {type: String, stringTransform: function(string) {\n  // Type will ALWAYS be String, so using string prototype is OK.\n  return string.toUpperCase();\n}}\n```\n\n### regex\nValidates string against Regular Expression. If string doesn't match, it's rejected.\n```js\nmemberCode: {type: String, regex: new RegExp('^([0-9A-Z]{4})$')}\n```\n\n### enum\nValidates string against array of strings. If not present, it's rejected.\n```js\ngender: {type: String, enum: ['m', 'f']}\n```\n\n### minLength\nEnforces minimum string length.\n```js\nnotEmpty: {type: String, minLength: 1}\n```\n\n### maxLength\nEnforces maximum string length.\n```js\nstateAbbrev: {type: String, maxLength: 2}\n```\n\n### clip\nIf true, clips string to maximum string length instead of rejecting string.\n```js\nbio: {type: String, maxLength: 255, clip: true}\n```\n\n\n## Number\n\n### min\nNumber must be > min attribute or it's rejected.\n```js\npositive: {type: Number, min: 0}\n```\n\n### max\nNumber must be < max attribute or it's rejected.\n```js\nnegative: {type: Number, max: 0}\n```\n\n\n## Array\n\n### arrayType\nElements within the array will be typed to the attributes defined.\n```js\naliases: {type: Array, arrayType: {type: String, minLength: 1}}\n```\n\nAn alternative shorthand version is also available -- wrap the properties within array brackets.\n```js\naliases: [{type: String, minLength: 1}]\n```\n\n### unique\nEnsures duplicate-free array, using === to test object equality.\n```js\nemails: {type: Array, unique: true, arrayType: String}\n```\n\n### filter\nReject any values where filter callback does not return truthy.\n```js\nemails: {type: Array, arrayType: Person, filter: (person) => person.gender !== 'f'}\n```\n\n\n## Object\n### objectType\nAllows you to define a typed object.\n```js\ncompany: {type: Object, objectType: {\n  name: String\n}}\n```\n\nAn alternative shorthand version is also available -- simply pass an instance of SchemaObject or a schema.\n```js\ncompany: {\n  name: String\n}\n```\n\n\n## Alias\n\n### index (required)\nThe index key of the property being aliased.\n```js\nzip: String,\npostalCode: {type: 'alias', alias: 'zip'}\n// this.postalCode = 12345 -> this.toObject() -> {zip: '12345'}\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/scotthovestadt/schema-object.git"
  },
  "scripts": {
    "build": "gulp build",
    "prepublish": "in-publish && gulp build || not-in-publish",
    "test": "gulp test-node && gulp test-node"
  },
  "types": "./typescript/schemaobject.d.ts",
  "version": "4.0.11"
}
